# Carry Look-Ahead Adder

### What Carry Look-Ahead Adder?

The adder produce carry propagation delay while performing other arithmetic operations like multiplication and divisions as it uses several additions or subtraction steps. This is a major problem for the adder and hence improving the speed of addition will improve the speed of all other arithmetic operations. Hence reducing the carry propagation delay of adders is of great importance. There are different logic design approaches that have been employed to overcome the carry propagation problem. One widely used approach is to employ a carry look-ahead which solves this problem by calculating the carry signals in advance, based on the input signals. This type of adder circuit is called a carry look-ahead adder.

Here a carry signal will be generated in two cases:

Input bits A and B are 1 When one of the two bits is 1 and the carry-in is 1. In ripple carry adders, for each adder block, the two bits that are to be added are available instantly. However, each adder block waits for the carry to arrive from its previous block. So, it is not possible to generate the sum and carry of any block until the input carry is known. The i^{th} block waits for the i-1^{th} block to produce its carry. So there will be a considerable time delay which is carry propagation delay.


![logic block](https://github.com/madhumadhu1318/pes_cla_adder/assets/90201844/0c23ebeb-6ec7-4c10-b7f5-0db73b354dad)



Consider the above 4-bit ripple carry adder. The sum S_{3} is produced by the corresponding full adder as soon as the input signals are applied to it. But the carry input C_{4} is not available on its final steady-state value until carry C_{3} is available at its steady-state value. Similarly C_{3} depends on C_{2} and C_{2} on C_{1} . Therefore, though the carry must propagate to all the stages in order that output S_{3} and carry C_{4} settle their final steady-state value.

The propagation time is equal to the propagation delay of each adder block, multiplied by the number of adder blocks in the circuit. For example, if each full adder stage has a propagation delay of 20 nanoseconds, then S_{3} will reach its final correct value after 60 (20 Ã— 3) nanoseconds. The situation gets worse, if we extend the number of stages for adding more number of bits.

Carry Look-ahead Adder : A carry look-ahead adder reduces the propagation delay by introducing more complex hardware. In this design, the ripple carry design is suitably transformed such that the carry logic over fixed groups of bits of the adder is reduced to two-level logic. Let us discuss the design in detail.



## Installation

For installation and more details regarding iverilog, yosys and gtkwave, refer to :

https://github.com/madhumadhu1318/PES_ASIC_CLASS


## Simulation

+ `iverilog pes_cla_adder.v  pes_cla_adder_tb.v`
+ `./a.out`
+ `gtkwave pes_cla_adder.vcd`

![Screenshot 2023-10-18 182122](https://github.com/madhumadhu1318/pes_cla_adder/assets/90201844/506e74ff-58fd-4250-99e3-9e6a381d3216)

![2](https://github.com/madhumadhu1318/pes_cla_adder/assets/90201844/20718a67-df59-45d1-9e30-493ca9152fe9)




## Synthesis
+ Invoke `yosys`
+ `read_liberty -lib lib/sky130_fd_sc_hd__tt_025C_1v80.lib`
+ `read_verilog pes_cla_adder.v pes_cla_adder_tb.v`
+ `synth -top pes_cla_adder.v`
+ `abc -liberty lib/sky130_fd_sc_hd__tt_025C_1v80.lib`
+ `flatten`
+ `write_verilog pes_cla_adder_netlist.v`
+ `show pes_cla_adder`








## Gate-Level Simulation

+ `iverilog my_lib/verilog_model/primitives.v my_lib/verilog_model/sky130_fd_sc_hd.v PES_RCA_netlist.v PES_RCA_TB.v`
+ `./a.out`
+ `gtkwave PES_RCA.vcd`


![Screenshot from 2023-10-18 17-11-32](https://github.com/Vinodkumar8318/PES_Ripple-CA/assets/142583979/4a17c7d8-2655-48d7-bc16-b6296053f8b1)


![Screenshot from 2023-10-18 17-12-11](https://github.com/Vinodkumar8318/PES_Ripple-CA/assets/142583979/fe61ee59-7b16-4340-bcf8-5ad0ef8a30fa)

 
![Screenshot from 2023-10-18 17-09-35](https://github.com/Vinodkumar8318/PES_Ripple-CA/assets/142583979/6e27ee1b-5b05-440a-88b8-9565190c18ee)


We can observe that output of functional simulation is matching with the output of gate level simulation, this means that the netlist generated by yosys is correct.
